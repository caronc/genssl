#!/bin/sh
# -*- encoding: utf-8 -*-
#
# SSL Certificate Generator & Certificate Verifier
#
# Copyright (C) 2014 Chris Caron <lead2gold@gmail.com>
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with subliminal. If not, see <http://www.gnu.org/licenses/>.
#
# ----------------------------------------------------------------------------
#
# The following packages are required for this script to work correctly:
#   dos2nuix, openssl

# It is based on the documentation found at:
#     http://httpd.apache.org/docs/2.2/ssl/ssl_faq.html
#
#
# SSL .key file -- This is the private key. It may be created with a passphrase
#                  but this is not recommended as it requires a passphrase
#                  entry when the httpd service is started and with multiple
#                  entries (keys) it can cause httpd not to start.
#
# SSL .csr File -- If there is a plan to have the certificate signed, this is
#                  the Certificate Signing Request that is needed. It is
#                  transmitted to a company such as "VeriSign" where they will
#                  complete a verification process and give back a final .crt
#                  (public key) file. This file is only created when you want
#                  to properly register your secure website over the internet.
#                  This file is not used or applicable to "self-signed" keys
#                  which is another option this script can handle for you. Use
#                  a self-signed key for private networks might save you and/or
#                  your company a lot of money.
#
# SSL .crt File -- This is the public key. It is automatically transmitted to
#                  anyone who attempts an https:// connection on a web browser
#                  or those accessing a secure mail server, ftp server, etc.
#                  This key allows clients to decrypt content you send to them
#                  through the use of the private key it pairs up against.
#
#                  This file is automatically generated when creating a self-
#                  signed certificate or test certificate.  Otherwise, it is
#                  provided to you by a Certificate Signing Request Server after
#                  you pay them in addition to applying them a generated
#                  unsigned certificate file (.csr). If your certificate isn't
#                  signed, then just know in advance that a warning will be
#                  triggered for all clients accessing you secure (web, ftp,
#                  smtp, ldap, pop3, etc) site for the first time. The warning
#                  will just let them know that the certificate's authenticity
#                  cannot be verified. Most client applications can be
#                  configured to remember this certificate and always accept it.
#
# ----------------------------------------------------------------------------
SSLID=$1
DOMAIN=$2

# Source any over-riding keys if nessesary
[  -f /etc/genssl ] && . /etc/genssl
[  -f ~/.config/genssl ] && . ~/.config/genssl
[  -f ~/.genssl ] && . ~/.genssl

# Preconfigurables
GENSSL_COUNTRY=${GENSSL_COUNTRY:="7K"}
GENSSL_ORG=${GENSSL_ORG:="Lannisters"}
GENSSL_PROVSTATE=${GENSSL_PROVSTATE:="Westerlands"}
GENSSL_LOCATION=${GENSSL_LOCATION:="Casterly Rock"}
GENSSL_DEPT=${GENSSL_DEPT:=""}
GENSSL_SHA=${GENSSL_SHA:="sha256"}

## 730 is (365 * 2) - 2 Years
GENSSL_EXPIRYDAYS=${GENSSL_EXPIRYDAYS:="730"}

## Setting This To 1 causes the key to be generated with a pass phrase
## This is fine; but remember; each time the service requiring the key is
## started up; you will be required to be entered the password. This
## ensures the utmost security; but can also be cumbersome if you manage
## hundreds (or thousands) of servers; you'll need to enter a passphrase
## each time.
USEPASSPHRASE=${USEPASSPHRASE:="0"}

## There is no real reason to change this value at this time.
PASSPHRASESWITCH=${PASSPHRASESWITCH:="-des3"}

## Valid Keysizes are 512, 1024 and 2048
## The 512 keysizes were compromized in 2010 and by default the openssl tool
## generates 1024.  However, Entrust (at the time the people we were using only
## allow key sizes of 2048
GENSSL_KEYSIZE=${GENSSL_KEYSIZE:="2048"}

# Attempt to determine our IP address if possible
GENSSL_MYIP=${GENSSL_MYIP:=""}
[ -z "$GENSSL_MYIP" ] && GENSSL_MYIP=127.0.0.1

## Default Key Types are as follows:
# 0 = Unsigned Certificate (must be passed to a CA for signing)
# 1 = Self Signed Certificate
# 2 = Test Key
KEYTYPE=

# Internal Switch references
QUIETSWITCH=0
YESSWITCH=0

show_syntax () {
   echo "Author: Chris Caron <lead2gold@gmail.com>"
   echo "Version: 1.0.0"
   echo "Description: An SSL/TLS Certificate Generator & Certificate Verifier"
   echo
   echo "Syntax: \$> genssl -[s|r|t|v] [options] domain1 [domain2 [...]]"
   echo "  Actions:"
   echo "     -v"
   echo "     --verify            Verify generated keys."
   echo
   echo "     -s"
   echo "     --self-signed       Generate a self signed-key."
   echo
   echo "     -r"
   echo "     --registered        Generate a registered key. This must be"
   echo "                          sent to third party to have certificate"
   echo "                          officially signed."
   echo "     -t"
   echo "     --test-key          Generate a test key This is similar to self-"
   echo "                          signed but without an expiry date."
   echo "  Options:"
   echo "     -p"
   echo "     --use-passphrase    Generated key to include a passphrase"
   echo
   echo "     -e DAYS"
   echo "     --expiry-date=DAYS  Set the expiry date of a self-signed key."
   echo "                          The value must be between 1 and 999;"
   echo "                          Default is '$GENSSL_EXPIRYDAYS'"
   echo "     -c CODE"
   echo "     --countrycode=CODE  Set country code; Default is '$GENSSL_COUNTRY'"
   echo
   echo "     -P PROVINCE"
   echo "     --province=PROVINCE Set province; Default is '$GENSSL_PROVSTATE'"
   echo "                          This is the same field as the --state (-a)"
   echo "     -a STATE"
   echo "     --state=STATE       Set state; Default is '$GENSSL_PROVSTATE'"
   echo "                          This is the same field as the --province (-P)"
   echo
   echo "     -l LOCATION"
   echo "     --location=LOCATION Set location; Default is '$GENSSL_LOCATION'"
   echo
   echo "     -o ORG"
   echo "     --organization=ORG  Set organization; Default is '$GENSSL_ORG'"
   echo
   echo "     -d DEPT"
   echo "     --department=DEPT   Set department; Default is '$GENSSL_DEPT'"
   echo
   echo "     -h"
   echo "     --help              Show this help screen"
   echo
   echo
}

## STDOUT Control
echo_stdout () {
   if [ $QUIETSWITCH -eq 0 ]; then
      echo "$@"
   fi
}

prompt_Yn() {
  QUESTION=$1
  DEFAULT=$2
  ## Return 0 always unless
  ## quiet switch isn't specified.. then allow
  ## over-ride value
  RET=0
  ## Store Default (if not set)
  if [ -z "$DEFAULT" ]; then
     DEFAULT=0
  fi

  ## Prepare Y/N string Y=0, N=1
  YNSTR="[Y/n]"
  if [ $DEFAULT -ne 0 ]; then
    YNSTR="[y/N]"
  fi

  if [ $QUIETSWITCH -ne 0 ]; then
     return 0
  fi

  RET=$DEFAULT
  STRINGOUT="      |----> Do you want to continue? $YNSTR: "
  while [ 1 -eq 1 ]; do
     if [ ! -z "$QUESTION" ]; then
        echo_stdout "Question: $QUESTION"
     fi
     echo_stdout -n "$STRINGOUT"
     read -n 1 VAL

     if [ ! -z "$VAL" ]; then
        echo
        echo "$VAL" | egrep -q '[Nn]'
        if [ $? -eq 0 ]; then
           RET=1
           break;
        fi
        echo "$VAL" | egrep -q '[Yy]'
        if [ $? -eq 0 ]; then
           RET=0
           break;
        fi
     else
        ## Default
        return $DEFAULT
     fi
  done
  return $RET
}

verify_ssl () {
   local HOSTID=$1
   [ -z "$HOSTID" ] && return 1
   if [ ! -f "$HOSTID.key" ]; then
      echo_stdout "Warning: Verification of '$HOSTID' skipped; .key file was not found."
      return 1
   fi
   echo_stdout "Info: Verifying '$HOSTID' keys ..."

   ## verification
   local VERIFY1=
   local VERIFY2=$(openssl rsa -noout -modulus -in $HOSTID.key 2>/dev/null \
                  | openssl md5 2>/dev/null)
   if [ ${PIPESTATUS[0]} -ne 0 ]; then
      echo_stdout "       - $HOSTID.key ... Failed! (Corrupt/Invalid!)"
      return 1
   fi
   echo_stdout "       - $HOSTID.key ... Good!"

   if [ ! -f "$HOSTID.crt" ] && [ ! -f "$HOSTID.csr" ]; then
      echo_stdout "       - $HOSTID.crt ... Failed! (Missing)"
      echo_stdout "       - $HOSTID.key ... Failed! (Missing)"

      return 1
   fi

   # Initialize Return Value
   local RET=0

   if [ -f "$HOSTID.crt" ]; then
      echo_stdout -n "       - $HOSTID.crt ... "
      VERIFY1=$(openssl x509 -noout -modulus -in "$HOSTID.crt" 2>/dev/null \
                  | openssl md5 2>/dev/null)
      if [ ${PIPESTATUS[0]} -ne 0 ]; then
            echo_stdout "Failed! (Corrupt/Invalid)"
      else
         if [ "$VERIFY1" != "$VERIFY2" ]; then
            echo_stdout "Failed! (Mismatch)"
            RET=2
         else
            echo_stdout "Good!"
         fi
      fi
   fi

   if [ -f "$HOSTID.csr" ]; then
      # Only if a .crt wasn't found do we fall back and verify the .csr
      echo_stdout -n "       - $HOSTID.csr ... "
      VERIFY1=$(openssl req -noout -modulus -in $HOSTID.csr 2>/dev/null \
               | openssl md5)
      if [ ${PIPESTATUS[0]} -ne 0 ]; then
            echo_stdout "Failed! (Corrupt/Invalid)"
      else
         if [ "$VERIFY1" != "$VERIFY2" ]; then
            echo_stdout "Failed! (Mismatch)"
            RET=2
         else
            echo_stdout "Good!"
         fi
      fi
   fi
   return $RET
}

## Parse Input
ACTION=
if [ ! -z "$1" ]; then
   while : ; do
      case $1 in
         -h) show_syntax
               exit 0 ;;
         --help)
             show_syntax
               exit 0 ;;
         -v) ACTION=v
               shift ;;
         --verify)
             ACTION=v
               shift ;;
         -s) ACTION=k
             KEYTYPE=1
               shift ;;
         --self-signed)
             ACTION=k
             KEYTYPE=1
               shift ;;
         -r) ACTION=k
             KEYTYPE=0
               shift ;;
         --registered)
             ACTION=k
             KEYTYPE=0
               shift ;;
         -t) ACTION=k
             KEYTYPE=2
               shift ;;
         --test-key)
             ACTION=k
             KEYTYPE=2
               shift ;;
         -p) USEPASSPHRASE=1 ;
               shift ;;
         --use-passphrase)
             USEPASSPHRASE=1 ;
               shift ;;
         -c) GENSSL_COUNTRY=$2 ;
               shift; shift ;;
         --countrycode=*)
             GENSSL_COUNTRY=$(echo $1 | \
               sed -e 's/--countrycode=//g' -e "s/'//g" -e 's/\"//g') ;
               shift ;;
         -P) GENSSL_PROVSTATE=$2 ;
               shift; shift ;;
         --province=*)
             GENSSL_PROVSTATE=$(echo $1 | \
               sed -e 's/--province=//g' -e "s/'//g" -e 's/\"//g') ;
               shift ;;
         -a) GENSSL_PROVSTATE=$2 ;
               shift; shift ;;
         --state=*)
             GENSSL_PROVSTATE=$(echo $1 | \
               sed -e 's/--state=//g' -e "s/'//g" -e 's/\"//g') ;
               shift ;;
         -l) GENSSL_LOCATION=$2 ;
               shift; shift ;;
         --location=*)
             GENSSL_LOCATION=$(echo $1 | \
               sed -e 's/--location=//g' -e "s/'//g" -e 's/\"//g') ;
               shift ;;
         -e) GENSSL_EXPIRYDAYS=$2 ;
               shift; shift ;;
         --expiry-date=*)
             GENSSL_EXPIRYDAYS=$(echo $1 | \
               sed -e 's/--expiry-date=//g' -e "s/'//g" -e 's/\"//g' \
                     -e 's/[^\d]//g') ;
               shift ;;
         -o) GENSSL_ORG=$2 ;
               shift; shift ;;
         --organization=*)
             GENSSL_ORG=$(echo $1 | \
               sed -e 's/--organization=//g' -e "s/'//g" -e 's/\"//g') ;
               shift ;;
         -d) GENSSL_DEPT=$2 ;
               shift; shift ;;
         --department=*)
             GENSSL_DEPT=$(echo $1 | \
               sed -e 's/--department=//g' -e "s/'//g" -e 's/\"//g') ;
               shift ;;
          *) break ;;
      esac
   done
   DOMAINS=$@
else
   show_syntax
   exit 1
fi

if [ -z "$ACTION" ]; then
   show_syntax
   exit 1
fi

if [ $USEPASSPHRASE -eq 0 ]; then
   PASSPHRASESWITCH="-nodes"
fi

if [ -z "$DOMAINS" ] && [ "$ACTION" == "v" ]; then
   # Detect domains
   DOMAINS=$(find . -maxdepth 1 -mindepth 1 \
                  -type f -name '*.key' -exec basename {} \; \
                  | sed -e 's|^\(.*\)\.key$|\1|g')
fi

if [ -z "$DOMAINS" ]; then
   echo_stdout "Error: You must specify at least one domain name."
   show_syntax;
   exit 1
fi

RET=0
for DOMAIN in $DOMAINS; do
   echo_stdout "$DOMAIN" | egrep -q '[^A-Za-z0-9_.]'
   if [ $? -eq 0 ]; then
      echo_stdout "Error: The domain $DOMAIN contains invalid characters."
      continue
   fi

   SSLID=$(echo $DOMAIN | tr '[:upper:]' '[:lower:]')
   if [ $ACTION == "v" ]; then
      verify_ssl $SSLID
      continue
   fi
   # If we reach here; then we're generating new keys
   if [ -f "$SSLID.key" ] || [ -f "$SSLID.csr" ] || [ -f "$SSLID.crt" ]; then
      prompt_Yn "'$SSLID' appears to be already generated." 1
      [ $? -eq 1 ] && continue
   fi

   # Eliminate any existing entries
   rm -rf "$SSLID.csr" "$SSLID.crt" "$SSLID.key" "$SSLID.README" &>/dev/null

   ## Create Private Key
   if [ $KEYTYPE -eq 0 ]; then
      echo_stdout "Info: Creating an Unsigned Certificate for $SSLID (expiry: $GENSSL_EXPIRYDAYS days)"
      # Create a Certificate Signing Request (CSR) with the server RSA private
      # key (output will be PEM formatted)
      ERR=$(openssl req $PASSPHRASESWITCH -new -$GENSSL_SHA \
            -newkey rsa:$GENSSL_KEYSIZE \
            -keyout $SSLID.key \
            -out $SSLID.csr \
            -subj "/C=$GENSSL_COUNTRY/ST=$GENSSL_PROVSTATE/L=$GENSSL_LOCATION/O=$GENSSL_ORG/OU=$GENSSL_DEPT/CN=$DOMAIN" 2>&1)
      RET=$?

     # When you get back your signed certificate (as a .crt file) you
     # will want to rename it to server.crt
     # This isn't truely necessary but allows you to verify that they
     # key is valid and is going to work for you.

     # openssl verify -CAfile /path/to/trusted_ca.crt \
     #                          -purpose sslserver server.crt

     # You can try the default Red Hat / CentOS one:
     # openssl verify -CAfile /etc/pki/tls/certs/ca-bundle.crt \
     #                          -purpose sslserver server.crt

   elif [ $KEYTYPE -eq 1 ]; then
      ## Self Signed
      if [ $GENSSL_EXPIRYDAYS -le 1 ] || [ $GENSSL_EXPIRYDAYS -gt 999 ]; then
         echo_stdout "Error: Expiry days must be between 1 and 999"
         exit 1
      fi
      echo_stdout "Info: Creating Self-Signed Certificate for $SSLID (expiry: $GENSSL_EXPIRYDAYS days)"
      ERR=$(openssl req $PASSPHRASESWITCH -new -x509 -days $GENSSL_EXPIRYDAYS -$GENSSL_SHA \
            -newkey rsa:$GENSSL_KEYSIZE \
            -keyout $SSLID.key \
            -out $SSLID.crt \
            -subj "/C=$GENSSL_COUNTRY/ST=$GENSSL_PROVSTATE/L=$GENSSL_LOCATION/O=$GENSSL_ORG/OU=$GENSSL_DEPT/CN=$DOMAIN" 2>&1)
      RET=$?
   else
      ## Testing Key
      ERR=$(openssl req $PASSPHRASESWITCH -x509 -new -$GENSSL_SHA \
            -newkey rsa:$GENSSL_KEYSIZE \
            -keyout $SSLID.key \
            -out $SSLID.crt \
            -subj "/C=$GENSSL_COUNTRY/ST=$GENSSL_PROVSTATE/L=$GENSSL_LOCATION/O=$GENSSL_ORG/OU=$GENSSL_DEPT/CN=$DOMAIN" 2>&1)
      RET=$?
   fi

   if [ $RET -eq 0 ]; then
      [ -f $SSLID.csr ] && \
         echo_stdout "Info: Generated $SSLID.csr (Unsigned Certificate)"
      [ -f $SSLID.crt ] && \
         echo_stdout "Info: Generated $SSLID.crt (Public Key)"
      [ -f $SSLID.key ] && \
         echo_stdout "Info: Generated $SSLID.key (Private Key)"

   if [ $RET -eq 0 ]; then
      verify_ssl $SSLID
      if [ $? -ne 0 ]; then
         echo_stdout "Error: Keys for $SSLID were not created properly!"
         rm -rf $SSLID.csr $SSLID.crt $SSLID.key $SSLID.README &>/dev/null
         continue
      fi
   fi

   echo_stdout -n "Info: Generating $SSLID.README..."
   cat << _EOF > $SSLID.README
README for Domain: $SSLID
Generated: $(date +'%Y/%m/%d %H:%S:%M')

# Keys should be placed as follows:
   $> install -o root -g root -m0444 $SSLID.crt \\
         /etc/pki/tls/certs/$SSLID.crt
   $> install -o root -g root -m0400 $SSLID.key \\
         /etc/pki/tls/private/$SSLID.key

Apache Config Example
=====================
   <VirtualHost $GENSSL_MYIP:443>
      ...or
      SSLEngine  on
      SSLCertificateFile /etc/pki/tls/certs/$SSLID.crt
      SSLCertificateKeyFile /etc/pki/tls/private/$SSLID.key
      ...

   </VirtualHost>

Nginx Config Example
====================
   server {
      listen       $GENSSL_MYIP:443;
      ...

      ssl on;
      ssl_certificate_key /etc/pki/tls/private/$SSLID.key;

      ## You'll only want to uncomment 1 (one) of the options identified
      ## below:

      ## (1) Uncomment the following if you created a .ca.crt file
      ##     from following the 'signed' certificate instructions:
      #ssl_certificate /etc/pki/tls/certs/$SSLID.ca.crt;

      ## (2) Uncomment the following line if you are using a 'unsigned',
      ##     'test' certificate. This line should also be uncommented if
      ##     you created a 'signed' certificate and the Certificate Authority
      ##     you chose did not provide you with enough information to
      ##     generate a ca.crt file (using the Root and ChainRoot keys):
      #ssl_certificate /etc/pki/tls/certs/$SSLID.crt;


      ssl_session_timeout  5m;
      ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
      ssl_ciphers 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128:AES256:AES:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK';
      ssl_prefer_server_ciphers on;
      ssl_session_cache  builtin:1000  shared:SSL:10m;

      ...
   }

_EOF

      if [ -f "$SSLID.csr" ]; then
         cat << _EOF >> $SSLID.README

You now have to send this Certificate Signing Request (CSR) to a
Certifying Authority (CA) to be signed. Once the CSR has been signed,
you will have a real Certificate, which can be used by Apache, NginX,
Lighttpd, etc... You can have a CSR signed by a commercial CA, or you
can create your own CA to sign it.

Commercial CAs usually ask you to post the CSR into a web form, pay
for the signing, and then send a signed Certificate, which you can
store in a server.crt file. For more information about commercial
CAs see the following locations:

   1. Verisign
       http://digitalid.verisign.com/server/apacheNotice.htm
   2. Thawte
       http://www.thawte.com/
   3. CertiSign Certificadora Digital Ltda.
       http://www.certisign.com.br
   4. IKS GmbH
       http://www.iks-jena.de/leistungen/ca/
   5. Uptime Commerce Ltd.
       http://www.uptimecommerce.com
   6. BelSign NV/SA
       http://www.belsign.be

I recommend you run the following against your retrieved content from
your chosen Certificate Authority (CA) when they provide you with the
signed certificate (.crt). Rename it to '$SSLID.crt' for consistency
and clean up it's contents (just in case):
   # Eliminate any windows characters
   dos2unix $SSLID.crt
   # Trim all trailing empty new lines
   sed -i -e '/^[ \t]*$/d' $SSLID.crt

Consider verifying it to ensure it's contents are okay:

   # Verify Signed Certificate
   openssl verify -CAfile /etc/pki/tls/certs/ca-bundle.crt \\
                  -purpose sslserver $SSLID.crt


Some CA's will additionally provide you with a Root and Chain Root Certificate
files.  Some browsers (like NginX) will want you to include these in addition
to the signed certificate.  We generate a .ca.crt file like so:
   # Create a copy of our original Certificate
   cp $SSLID.crt $SSLID.ca.crt

   # Convert Root and ChainRoot files (ensure they're unix format)
   dos2unix L1Croot.txt
   dos2unix L1Cchainroot.txt

   # Trim all trailing empty new lines
   sed -i -e '/^[ \t]*$/d' L1Croot.txt
   sed -i -e '/^[ \t]*$/d' L1Cchainroot.txt

   # Append our Certificate Authoritive information to the end of our
   # signed certificate:
   cat L1Croot.txt >> $SSLID.ca.crt
   cat L1Cchainroot.txt >> $SSLID.ca.crt

   # Now you can install your certificate:
   install -o root -g root -m0444 $SSLID.crt \\
         /etc/pki/tls/certs/$SSLID.crt
   install -o root -g root -m0444 $SSLID.ca.crt \\
         /etc/pki/tls/certs/$SSLID.crt

   # If you did get A Root and Chain Root file; it wouldn't hurt to
   # store these too. But call them by the same name as your Certificate
   # Authority server goes by. For instance; if your using Entrust
   # consider the following:
   install L1Croot.txt -o root -g root -m0444 \\
         /etc/pki/tls/certs/entrust.ca.key
   install L1Cchainroot.txt -o root -g root -m0444 \\
         /etc/pki/tls/certs/entrust.chain.key

   # Note: These don't change often (if ever); It's worth always storing
   #       the latest one you got here, but if you generate 10 keys, you
   #       don't need to decide which .ca.key and .chain.key to keep.
   #       They're all the same in these cases (no need to save each one
   #       individually either!)
_EOF
      fi
      echo_stdout " Done."
   fi
done
exit $RET
